<!DOCTYPE html>
<html lang="en-us">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=51372&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HP z620 UEFI Backdoor · x86sec</title>

  <meta name="description" content="Vulnerability research, kernel exploitation, and reverse engineering.">
  <meta name="author" content="Grant Foudree">

  
  <meta property="og:title" content="HP z620 UEFI Backdoor">
  <meta property="og:type" content="website">
  <meta property="og:url" content="http://localhost:51372/post/hp-z620-uefi-backdoor/">

  
  <link rel="canonical" href="http://localhost:51372/post/hp-z620-uefi-backdoor/">
  <link rel="alternate" type="application/rss+xml" title="x86sec" href="http://localhost:51372/index.xml">

  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" href="/css/main.css">

  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
</head>
<body><header class="site-header">
  <div class="container">
    <a class="site-logo" href="/" data-text="[x86sec]"><span class="bracket">[</span>x86sec<span class="bracket">]</span></a>
    <nav class="site-nav">
      
      <a href="/"
         class="active">
        posts
      </a>
      
      <a href="/about/"
         class="">
        about
      </a>
      
    </nav>
  </div>
</header>
<main>
<div class="container">

  
  <div class="page-hero">
    <h1>HP z620 UEFI Backdoor</h1>
    
    <div class="hero-meta">
      <span><span class="dot">date</span> April 25, 2021</span>
      
      <span><span class="dot">read</span> 5 min</span>
      
      <span>
        
        <a href="/tags/z620" class="tag">z620</a>
        
        <a href="/tags/reverse-engineering" class="tag">reverse engineering</a>
        
        <a href="/tags/uefi" class="tag">uefi</a>
        
        <a href="/tags/backdoor" class="tag">backdoor</a>
        
        <a href="/tags/malware" class="tag">malware</a>
        
        <a href="/tags/persistent" class="tag">persistent</a>
        
        <a href="/tags/ghidra" class="tag">ghidra</a>
        
        <a href="/tags/efi" class="tag">efi</a>
        
      </span>
      
    </div>
    
  </div>

  
  <div class="post-content">
    <article class="prose">
      <h2 id="firmware-analysis">Firmware Analysis</h2>
<p>Picking apart firmware is quite interesting to me and so I thought it would be fun to reverse engineer my desktop&rsquo;s BIOS and see what I could find.</p>
<h2 id="extracting-uefi-modules">Extracting UEFI Modules</h2>
<p>My desktop is an HP z620 and the latest BIOS version is <a href="/J61_0396.bin">J61_0396.bin</a>. Most UEFI BIOS images are a collection of modules (drivers, microcode, applications, etc&hellip;) that can be extracted and examined. The drivers and applications are PE32+ executables which is convenient as many reverse engineering tools support this executable format. We can examine/modify the BIOS image with <a href="https://github.com/LongSoft/UEFITool">UEFITool</a> and pick apart the sections of interest.</p>
<p>An easy section to look at is where the POST logo is stored. Here it&rsquo;s conveniently called &ldquo;Logo&rdquo; and we can extract it as a <code>.bmp</code> file and see it is the same logo shown during POST.</p>
<p><img src="/bios_logo.webp" alt="Placeholder image" title="UEFITool bios logo section"> <img src="/hp_bios_logo.webp" alt="Placeholder image" title="HP BIOS logo">
<br></p>
<p>Sifting through the remaining sections, <code>BiosDiags</code> and <code>AbsoluteDriver</code> stood out as interesting as they are both applications.
<br>
<br></p>
<p><img src="/uefi_biosdiags_efi.webp" alt="Placeholder image" title="UEFITool BiosDiags.efi">
<br></p>
<h2 id="reverse-engineering-biosdiagsefi">Reverse Engineering BiosDiags.efi</h2>
<p>After extracting the <code>BiosDiags</code> section (Right-click &ldquo;PE32 Image Section&rdquo; -&gt; &ldquo;Extract Body&rdquo;), let&rsquo;s open it up in Ghidra to have a look&hellip;</p>
<p><strong>Note:</strong> to help with analyzing BIOS images, the plugins <a href="https://github.com/al3xtjames/ghidra-firmware-utils">ghidra-firmware-utils</a> and <a href="https://github.com/DSecurity/efiSeek">efiSeek</a> are helpful.</p>
<p>Looking for strings, <code>rpcnetp.exe</code> shows up inside shortly followed by the familiar <code>MZ</code> header which indicates a PE executable file. Interesting&hellip; The suspected PE executable is in the <code>.data</code> section of <code>BiosDiags.efi</code> which further raises suspicion that this is an embedded program to be dumped somewhere and not executed as part of <code>BiosDiags.efi</code>.</p>
<p><img src="/embedded_pe_header.webp" alt="Placeholder image" title="embedded PE header"></p>
<h2 id="running-biosdiagsefi">Running BiosDiags.efi</h2>
<p>Let&rsquo;s confirm our suspicions and run <code>BiosDiags.efi</code> in QEMU with an attached disk with Windows XP installed to see what happens.</p>
<p>An easy way to run EFI programs is launch QEMU with a UEFI BIOS, get a UEFI shell and invoke the program from there. Download a UEFI shell (or use <a href="/Shell.efi">this one</a>) and build an EFI-bootable FAT32 disk.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>dd <span style="color:#66d9ef">if</span><span style="color:#f92672">=</span>/dev/zero of<span style="color:#f92672">=</span>disk.img bs<span style="color:#f92672">=</span>1M count<span style="color:#f92672">=</span><span style="color:#ae81ff">64</span>
</span></span><span style="display:flex;"><span>mkfs.msdos disk.img
</span></span><span style="display:flex;"><span>mmd -i disk.img ::/EFI
</span></span><span style="display:flex;"><span>mmd -i disk.img ::/EFI/BOOT
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## Copy in shell &amp; BiosDiags.efi</span>
</span></span><span style="display:flex;"><span>mcopy -i disk.img Shell.efi ::/EFI/BOOT/Bootx64.efi
</span></span><span style="display:flex;"><span>mcopy -i disk.img BiosDiags.efi ::/
</span></span></code></pre></div><p>Invoke QEMU and attach a disk image with Windows XP installed (you can install the OVMF UEFI firmware on Ubuntu with <code>apt install ovmf</code>)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>qemu-system-x86_64 -drive format<span style="color:#f92672">=</span>raw,file<span style="color:#f92672">=</span>disk.img <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>    -smp <span style="color:#ae81ff">2</span> -m <span style="color:#ae81ff">4096</span> -bios /usr/share/qemu/OVMF.fd <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>    -drive media<span style="color:#f92672">=</span>disk,file<span style="color:#f92672">=</span>WindowsXP_1.vmdk 
</span></span></code></pre></div><p>Once QEMU starts up, you can drop into a shell and invoke <code>BiosDiags.efi</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>FS0:
</span></span><span style="display:flex;"><span>BiosDiags.efi
</span></span></code></pre></div><p><img src="/qemu_biosdiags_efi.webp" alt="qemubiosdiags" title="running BiosDiags.efi in QEMU"></p>
<p>Booting up XP we can see that two new files are implanted in <code>C:\Windows\System32\</code> as suspected (<code>rpcnetp.exe</code> and <code>rpcnetp.dll</code>) and <code>rpcnetp.exe</code> is running as <code>SYSTEM</code> on the machine. Nice!</p>
<p><img src="/backdoor_running.webp" alt="xpbackdoor" title="backdoor running"></p>
<p>It is worth noting that trying this again on a Windows 7 machine does not produce the same results, and no <code>rpcnet.exe</code> is dropped.</p>
<h2 id="wpbt-windows-platform-binary-table">WPBT (Windows Platform Binary Table)</h2>
<p>This sort of behavior looks a lot like a bootkit but, to my surprise, Windows provides an official way to do this via the <a href="https://download.microsoft.com/download/8/A/2/8A2FB72D-9B96-4E2D-A559-4A27CF905A80/windows-platform-binary-table.docx">Windows Platform Binary Table</a> (WPBT). In essence, the WPBT allows UEFI firmware to register a PE file to be run during system initialization by inserting it into an ACPI table. The ACPI table format looks like this (see above link for full details):</p>
<p><img src="/wpbt_layout.webp" alt="wpbtlayout" title="wpbt layout"></p>
<p>It appears as if this is exactly what is going on here. Let&rsquo;s have a look.</p>
<p><img src="/acpi_table_manipulation.webp" alt="acpitable" title="acpi table manipulation">
<br>
In this function, <code>0x80005de0</code>, we can see it accessing some ACPI tables in the beginning.</p>
<p>In Microsoft&rsquo;s documentation for WPBT, UEFI firmware is supposed to allocate memory for the WPBT ACPI table via the <code>AllocatePages()</code> service with an allocation type of <code>AllocateAnyPages</code> and the <code>EfiACPIReclaimMemory</code> flag set. This is <strong>exactly</strong> what we see later on inside <code>0x80005de0</code> :).</p>
<br>
![allocpages](/acpi_alloc_pages.webp "alloc pages")
<br>
<p>Lines 64 &amp; 65 perform this allocation, with line 68 invoking a function that takes in the PE code for the dropped <code>rpcnetp.exe</code> file. Finally, line 69 stores the result in <code>Table</code> which is our ACPI table that will be used to implement WPBT.</p>
<br>
![wpbttable](/wpbt_table.webp "wpbt table")
<br>
<p>Continuing on, we can see the WPBT fields being filled out per the specification. Line 111 sets the mandatory <code>WPBT</code> signature (<code>0x54425057</code> translates to &ldquo;WPBT&rdquo;). On line 119 we can see the <code>DAT_800010a8</code> value referenced again and set as the length of the PE data (<code>puVar14</code> is a 32-bit variable so <code>puVar14[9]</code> = 4*9 -&gt; 36). The content flag is set to 1 (indicating a PE file) and finally the memory location is set to that allocated buffer the PE data was copied into above.</p>
<p>Skipping over some lines, we eventually come to the end of the function where we can see the new ACPI table being installed with <code>InstallConfigurationTable()</code> and it&rsquo;s GUID, exactly as outlined in Microsoft&rsquo;s documentation.
<br></p>
<p><img src="/install_wpbt.webp" alt="installwpbt" title="wpbt install"></p>
<h2 id="dropped-file-analysis">Dropped file analysis</h2>
<p>Running both the files through Virustotal shows both files flagging 1 AV out of 67 (<a href="https://www.virustotal.com/gui/file/1c6a20980a186225979f5e91bc48eaf77c67f50eea85eba9db4c3ec55c61d55f/detection">rpcnetp.exe</a> <a href="https://www.virustotal.com/gui/file/56c9ab9a663af6af931b3c76f32ed0f7402d6ed39f3538f72cb2757886ef7c40/detection">rpcnetp.dll</a>)</p>
<p>Digging further, it appears this program is called &ldquo;Computrace&rdquo; and has been around for a while. I suppose the string at the beginning of the EFI file should have alerted me to this as well&hellip;</p>
<p><img src="/computrace.webp" alt="computrace" title="computrace"></p>
<p>If you&rsquo;re interested, you can read more about it here from this <a href="http://blackhat.com/docs/us-14/materials/us-14-Kamlyuk-Kamluk-Computrace-Backdoor-Revisited.pdf">Blackhat 14 Presentation</a> which goes over what it does.</p>
<h2 id="closing-thoughts">Closing thoughts</h2>
<p>While it appears as if Computrace does not deploy on newer Windows installations, it is important to realize this method of stealthily dropping executables into a OS install is a very real concept and is being used. Microsoft provides a way for vendors to do this so it is highly likely other software is being installed this way as well. Although other operating systems, like Linux, don&rsquo;t provide a built-in way to do this, accessing the disk in a pre-boot environment and dropping executables or modifying the guest OS is quite realistic. Since BIOS code is mostly black-box software that runs with high privilege before the OS boots, one should realize the trust we place in this firmware that we cannot control nor do we understand everything it does.</p>
<h2 id="files">Files</h2>
<h4 id="hp-bios--efi-modules">HP BIOS &amp; EFI Modules</h4>
<p><a href="/BiosDiags.efi"><code>BiosDiags.efi</code></a>:<code>71b01f0ad7c1d990771aa675bc814d5f9b50a7958c005173cda0165139235666</code>
<a href="/J61_0396.bin"><code>J61_0396.bin</code></a>:<code>05e89382e73afb280f637acbfa1029e9107dd30c78df37b6a00f184657f5f2c3</code></p>
<h4 id="uefi-bios-for-qemu">UEFI BIOS for QEMU</h4>
<p><a href="/OVMF.fd"><code>OVMF.fd</code></a>:<code>96a9aad279ac9fdb7d452b70cee71587a917aaa428e4c40e9a9cb35f5d718259</code>
<a href="/Shell.efi"><code>Shell.efi</code></a>:<code>04c89f19efee2a22660fd4650ff9add88e962d102b1b713e535f4e32a07c5185</code></p>
<h4 id="computrace">Computrace</h4>
<p><a href="/rpcnetp.dll"><code>rpcnetp.dll</code></a>:<code>56c9ab9a663af6af931b3c76f32ed0f7402d6ed39f3538f72cb2757886ef7c40</code>
<a href="/rpcnetp.exe"><code>rpcnetp.exe</code></a>:<code>1c6a20980a186225979f5e91bc48eaf77c67f50eea85eba9db4c3ec55c61d55f</code></p>

    </article>

    
    
    <div class="pagination" style="margin-top:3rem;">
      <a href="http://localhost:51372/post/gnu-barcode-heap-overflow/">← AFL&#43;&#43;: Finding several heap overflows in GNU Barcode 0.99</a>
      <a href="http://localhost:51372/post/advanced-qemu-debugging/">Advanced QEMU Debugging - Trace Events →</a>
    </div>
    
  </div>

</div>

  </main><footer class="site-footer">
  <div class="container">
    <div class="footer-left">
      <strong>x86sec</strong> — a cybersecurity blog<br>
      &copy; 2026 Grant Foudree
    </div>
    <div class="footer-links">
      <a href="https://github.com/gfoudree" rel="noopener">github</a>
    </div>
  </div>
</footer>
<script src="/js/main.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>
