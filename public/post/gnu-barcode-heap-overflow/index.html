<!DOCTYPE html>
<html lang="en-us">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=51372&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AFL&#43;&#43;: Finding several heap overflows in GNU Barcode 0.99 · x86sec</title>

  <meta name="description" content="Vulnerability research, kernel exploitation, and reverse engineering.">
  <meta name="author" content="Grant Foudree">

  
  <meta property="og:title" content="AFL&#43;&#43;: Finding several heap overflows in GNU Barcode 0.99">
  <meta property="og:type" content="website">
  <meta property="og:url" content="http://localhost:51372/post/gnu-barcode-heap-overflow/">

  
  <link rel="canonical" href="http://localhost:51372/post/gnu-barcode-heap-overflow/">
  <link rel="alternate" type="application/rss+xml" title="x86sec" href="http://localhost:51372/index.xml">

  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" href="/css/main.css">

  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
</head>
<body><header class="site-header">
  <div class="container">
    <a class="site-logo" href="/" data-text="[x86sec]"><span class="bracket">[</span>x86sec<span class="bracket">]</span></a>
    <nav class="site-nav">
      
      <a href="/"
         class="active">
        posts
      </a>
      
      <a href="/about/"
         class="">
        about
      </a>
      
    </nav>
  </div>
</header>
<main>
<div class="container">

  
  <div class="page-hero">
    <h1>AFL&#43;&#43;: Finding several heap overflows in GNU Barcode 0.99</h1>
    
    <div class="hero-meta">
      <span><span class="dot">date</span> September 18, 2021</span>
      
      <span><span class="dot">read</span> 3 min</span>
      
      <span>
        
        <a href="/tags/afl" class="tag">afl</a>
        
        <a href="/tags/afl&#43;&#43;" class="tag">afl&#43;&#43;</a>
        
        <a href="/tags/fuzzing" class="tag">fuzzing</a>
        
        <a href="/tags/gnu-barcode" class="tag">gnu barcode</a>
        
        <a href="/tags/heap-overflow" class="tag">heap overflow</a>
        
        <a href="/tags/vulnerability" class="tag">vulnerability</a>
        
        <a href="/tags/gdb" class="tag">gdb</a>
        
      </span>
      
    </div>
    
  </div>

  
  <div class="post-content">
    <article class="prose">
      <h2 id="afl">AFL++</h2>
<p><a href="https://github.com/AFLplusplus/AFLplusplus">AFL++</a> is an improved version of AFL, a popular and successful fuzzer. In this article we will use it to discover a couple heap-overflow bugs in GNU Barcode 0.99.</p>
<h2 id="compiling">Compiling</h2>
<p>It is quite simple to use AFL++, especially if you have access to the source code of the program you are trying to fuzz.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># Install some deps on Ubuntu</span>
</span></span><span style="display:flex;"><span>apt install git clang make build-essential gcc-9-plugin-dev
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>git clone https://github.com/AFLplusplus/AFLplusplus.git
</span></span><span style="display:flex;"><span>cd AFLplusplus
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Set LLVM_CONFIG to point to your llvm-config binary</span>
</span></span><span style="display:flex;"><span>LLVM_CONFIG<span style="color:#f92672">=</span>llvm-config-10 make -j
</span></span></code></pre></div><h2 id="building-a-target">Building a Target</h2>
<p>AFL++ makes it rather easy here - all you have to do is replace <code>CC</code>/<code>CXX</code> with the <code>afl-clang-fast</code>/<code>afl-clang-fast++</code> file in your AFL++ build folder and it handles the rest.</p>
<p>For example with GNU Barcode 0.99:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>wget -qO - https://mirrors.sarata.com/gnu/barcode/barcode-0.99.tar.gz | tar vxz
</span></span><span style="display:flex;"><span>cd barcode-0.99
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>CC<span style="color:#f92672">=</span>../AFLplusplus/afl-cc ./configure
</span></span><span style="display:flex;"><span>make -j
</span></span></code></pre></div><h2 id="fuzzing-with-afl">Fuzzing With AFL++</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>mkdir /tmp/<span style="color:#f92672">{</span>in,out<span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Our example input, modify accordingly</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># (ex: PNG parser -&gt; copy .png here). Can have multiple files</span>
</span></span><span style="display:flex;"><span>echo hello &gt; /tmp/in/1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Run fuzzer</span>
</span></span><span style="display:flex;"><span>AFLplusplus/afl-fuzz -i /tmp/in/ -o /tmp/out/ -- barcode-0.99/barcode
</span></span></code></pre></div><p><asciinema-player src="/asciinema_casts/barcode_heapoverflow_afl.cast" cols="110" rows="35"></asciinema-player></p>
<p>Crash-causing inputs will be found in the <code>/tmp/out/default/crashes</code> folder where you can try and reproduce the bug.
<br>
<br></p>
<h2 id="heap-overflows">Heap Overflows</h2>
<h2 id="overflow-1">Overflow 1</h2>
<p>The first overflow I found occured when GNU Barcode tried to parse the following input:</p>
<p><a href="/gnubarcode_heapoverflow1_poc.bin"><code>heapoverflow1</code></a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>gfoudree@z620 /tmp/poc % xxd &lt; heapoverflow1
</span></span><span style="display:flex;"><span>00000000: <span style="color:#ae81ff">3109</span> <span style="color:#ae81ff">8000</span> 0a20 3f39 <span style="color:#ae81ff">0010</span> <span style="color:#ae81ff">3952</span> 0a47 <span style="color:#ae81ff">6847</span>  1.... ?9..9R.GhG
</span></span><span style="display:flex;"><span>00000010: 6cff 262b 0a                             l.&amp;+.
</span></span></code></pre></div><p>Compiling GNU Barcode with ASAN helps give a hint as to what is going on when the crash occurs.</p>
<p><img src="/gnu_barcode_heapoverflow1_asan.webp" alt="heapoverflow1" title="Clang ASAN Output"></p>
<p>Examining this further in GDB, it appears as if the following snippet in <code>code128.c:443</code> is responsible for the crash here.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>partial <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>( <span style="color:#ae81ff">6</span> <span style="color:#f92672">*</span> len <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span>); <span style="color:#75715e">// 40 bytes allocated
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Far more than 40 bytes are copied into the heap-allocated buffer
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>len; i<span style="color:#f92672">++</span>) 
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">strcat</span>(partial, codeset[codes[i]]);
</span></span></code></pre></div><p>Running the program in GDB while checking the ability to <code>free()</code> the buffer <code>partial</code> inside of the for loop succeeds several times until it is overflowed and the following output can be seen from PwnDBG:
`</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>pwndbg&gt; try_free partial
</span></span><span style="display:flex;"><span>General checks
</span></span><span style="display:flex;"><span>Tcache checks
</span></span><span style="display:flex;"><span>Using tcache_put
</span></span><span style="display:flex;"><span>Fastbin checks
</span></span><span style="display:flex;"><span>free<span style="color:#f92672">()</span>: invalid next size <span style="color:#f92672">(</span>fast<span style="color:#f92672">)</span> -&gt; next chunk<span style="color:#e6db74">&#39;s size not in [2*size_sz; av-&gt;system_mem]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    next chunk&#39;</span>s size is 0x3131323234, 2*size_sz is 0x10, system_mem is 0x21000
</span></span><span style="display:flex;"><span>----------
</span></span><span style="display:flex;"><span>Free should succeed!
</span></span></code></pre></div><p>The full debugging session demo is shown below.</p>
<p><asciinema-player src="/asciinema_casts/barcode_heapoverflow_1.cast" cols="120" rows="50"></asciinema-player>
<br></p>
<h2 id="overflow-2">Overflow 2</h2>
<p>The second one occurs with the following input:</p>
<p><a href="/gnubarcode_heapoverflow2_poc.bin"><code>heapoverflow2</code></a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>gfoudree@z620 /tmp/poc % xxd &lt; heapoverflow2 
</span></span><span style="display:flex;"><span>00000000: <span style="color:#ae81ff">3109</span> <span style="color:#ae81ff">3100</span> <span style="color:#ae81ff">1000</span> <span style="color:#ae81ff">0039</span> <span style="color:#ae81ff">0010</span> <span style="color:#ae81ff">3944</span> 0a47 <span style="color:#ae81ff">6865</span>  1.1....9..9D.Ghe
</span></span><span style="display:flex;"><span>00000010: 6c80 262b 0a                             l.&amp;+.
</span></span></code></pre></div><p>Here, ASAN gives us an even better hint that a heap overflow is occuring:</p>
<p><img src="/gnu_barcode_heapoverflow2_asan.webp" alt="heapoverflow2" title="Clang ASAN Output"></p>
<p>Digging through the source code and running the target in GDB, the source appears to be a different location inside of <code>code128.c:557</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Buffer allocated
</span></span></span><span style="display:flex;"><span>textinfo <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#ae81ff">12</span> <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span><span style="color:#f92672">+</span><span style="color:#a6e22e">strlen</span>(text)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>textptr <span style="color:#f92672">=</span> textinfo;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">strlen</span>(text); count<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">sscanf</span>(text <span style="color:#f92672">+</span> i, <span style="color:#e6db74">&#34;%u%n&#34;</span>, <span style="color:#f92672">&amp;</span>code, <span style="color:#f92672">&amp;</span>n) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        bc<span style="color:#f92672">-&gt;</span>error <span style="color:#f92672">=</span> EINVAL; 
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">free</span>(partial);
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">free</span>(textinfo);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">strcat</span>(partial, codeset[code]);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Overflow occurs here! 
</span></span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sprintf</span>(textptr, <span style="color:#e6db74">&#34;%g:9:%c %g:9:%c &#34;</span>, (<span style="color:#66d9ef">double</span>)textpos, 
</span></span><span style="display:flex;"><span>    code <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">100</span> <span style="color:#f92672">?</span> <span style="color:#e6db74">&#39;A&#39;</span> <span style="color:#f92672">:</span> code<span style="color:#f92672">/</span><span style="color:#ae81ff">10</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;0&#39;</span>,
</span></span><span style="display:flex;"><span>    textpos <span style="color:#f92672">+</span> (<span style="color:#66d9ef">double</span>)SYMBOL_WID<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>,	code<span style="color:#f92672">%</span><span style="color:#ae81ff">10</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;0&#39;</span>);
</span></span><span style="display:flex;"><span>    textptr <span style="color:#f92672">+=</span> <span style="color:#a6e22e">strlen</span>(textptr);
</span></span><span style="display:flex;"><span>    textpos <span style="color:#f92672">+=</span> SYMBOL_WID; <span style="color:#75715e">/* width of each code */</span>
</span></span><span style="display:flex;"><span>    i <span style="color:#f92672">+=</span> n;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The loop above continues to copy into the heap-allocated buffer without checking any sort of boundaries, eventually overflowing it.</p>
<h2 id="fixes--conclusion">Fixes &amp; Conclusion</h2>
<p>Over 90 crashing inputs were found after fuzzing GNU Barcode 0.99 for an hour. Of the 2 analyzed above, both are caused by an out-of-bounds write corrupting the heap which causes the subsequent <code>free()</code> in the program to operate on a smashed heap causing a crash.</p>
<p>In both instances, a safer function could have been used (<code>sprintf</code> -&gt; <code>snprintf</code> and <code>strcpy</code> -&gt; <code>strncpy</code>) which would only copy within the specified bounds and prevented both of these vulnerabilities.</p>

    </article>

    
    
    <div class="pagination" style="margin-top:3rem;">
      <a href="http://localhost:51372/post/removing-intel-me-on-x1-carbon/">← Removing Intel Management Engine From Lenovo X1 Carbon 6th Gen Laptop</a>
      <a href="http://localhost:51372/post/hp-z620-uefi-backdoor/">HP z620 UEFI Backdoor →</a>
    </div>
    
  </div>

</div>

  </main><footer class="site-footer">
  <div class="container">
    <div class="footer-left">
      <strong>x86sec</strong> — a cybersecurity blog<br>
      &copy; 2026 Grant Foudree
    </div>
    <div class="footer-links">
      <a href="https://github.com/gfoudree" rel="noopener">github</a>
    </div>
  </div>
</footer>
<script src="/js/main.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>
