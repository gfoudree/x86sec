<!DOCTYPE html>
<html lang="en-us">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=51372&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced QEMU Debugging - Trace Events · x86sec</title>

  <meta name="description" content="Vulnerability research, kernel exploitation, and reverse engineering.">
  <meta name="author" content="Grant Foudree">

  
  <meta property="og:title" content="Advanced QEMU Debugging - Trace Events">
  <meta property="og:type" content="website">
  <meta property="og:url" content="http://localhost:51372/post/advanced-qemu-debugging/">

  
  <link rel="canonical" href="http://localhost:51372/post/advanced-qemu-debugging/">
  <link rel="alternate" type="application/rss+xml" title="x86sec" href="http://localhost:51372/index.xml">

  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" href="/css/main.css">

  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
</head>
<body><header class="site-header">
  <div class="container">
    <a class="site-logo" href="/" data-text="[x86sec]"><span class="bracket">[</span>x86sec<span class="bracket">]</span></a>
    <nav class="site-nav">
      
      <a href="/"
         class="active">
        posts
      </a>
      
      <a href="/about/"
         class="">
        about
      </a>
      
    </nav>
  </div>
</header>
<main>
<div class="container">

  
  <div class="page-hero">
    <h1>Advanced QEMU Debugging - Trace Events</h1>
    
    <div class="hero-meta">
      <span><span class="dot">date</span> October 14, 2020</span>
      
      <span><span class="dot">read</span> 4 min</span>
      
      <span>
        
        <a href="/tags/qemu" class="tag">qemu</a>
        
        <a href="/tags/debugging" class="tag">debugging</a>
        
        <a href="/tags/osdev" class="tag">osdev</a>
        
      </span>
      
    </div>
    
  </div>

  
  <div class="post-content">
    <article class="prose">
      <h2 id="qemu">QEMU</h2>
<p>I enjoy working on operating system kernels and hypervisors, and for a lot of my personal work I use <a href="https://www.qemu.org/">QEMU</a> to help with my development and debugging. Here I&rsquo;ll demonstrate an advanced debugging feature in QEMU I&rsquo;ve found quite useful called &ldquo;trace events&rdquo;.</p>
<p>QEMU has a list of supported &ldquo;trace events&rdquo; to get more insight into the running guest OS. You can specify multiple trace commands
by adding <code>-d trace:&lt;name&gt;</code> to the QEMU command line. For example, tracing PCI configuration reads can be done with <code>qemu-system-x86_64 -d trace:pci_cfg_read</code>.</p>
<p>The full list of trace events can be found <a href="https://lxr.missinglinkelectronics.com/qemu+v2.5.1/trace-events">here</a>.</p>
<h2 id="keyboard">Keyboard</h2>
<p>When developing a keyboard driver, QEMU&rsquo;s ps2 keycode trace event is helpful to dump the keycodes out as they are pressed. The log formatting is <code>ps2_put_keycode(void *opaque, int keycode) &quot;%p keycode %d&quot;</code> <a href="https://lxr.missinglinkelectronics.com/qemu+v2.5.1/trace-events#L233">(source)</a> and the trace flag is <code>ps2_put_keycode</code>.</p>
<p>Pressing <code>g</code> on the keyboard inside the guest OS generates the following trace:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ps2_put_keycode 0x55e759f09cf0 keycode 0x34
</span></span><span style="display:flex;"><span>ps2_put_keycode 0x55e759f09cf0 keycode 0xf0
</span></span><span style="display:flex;"><span>ps2_put_keycode 0x55e759f09cf0 keycode 0x34
</span></span></code></pre></div><p>Neat!</p>
<h2 id="pci-device-readwrites">PCI Device Read/Writes</h2>
<p>Additionally, QEMU allows you to debug some activity on the PCI bus, such as reading configuration information, with the <code>pci_cfg_read</code> trace flag. I used this to test
<a href="https://github.com/gfoudree/cryptos/blob/b90dd6832accc438a0d71aa4e954e50fcf507f13/src/pci.c#L7">my OS code</a> for enumerating devices on the PCI bus which works by walking the bus/device/function combinations and issuing x86 port commands.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define PCI_CONFIG_ADDR_PORT 0xCF8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define PCI_CONFIG_DATA_PORT 0xCFC
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">uint32_t</span> <span style="color:#a6e22e">pci_read_config_word</span>(<span style="color:#66d9ef">uint8_t</span> bus, <span style="color:#66d9ef">uint8_t</span> device, 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint8_t</span> function, <span style="color:#66d9ef">uint8_t</span> reg) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> addr <span style="color:#f92672">=</span> (<span style="color:#66d9ef">uint32_t</span>)<span style="color:#ae81ff">0x80000000</span> <span style="color:#f92672">|</span> (<span style="color:#66d9ef">uint32_t</span>)(bus <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">16</span>) 
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">|</span> (device <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">11</span>) <span style="color:#f92672">|</span> (function <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">|</span> reg;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Use port I/O to get PCI info
</span></span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">outl</span>(PCI_CONFIG_ADDR_PORT, addr);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">inl</span>(PCI_CONFIG_DATA_PORT);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>My OS enumerates the virtual PCI devices QEMU provides to the guest as shown below.</p>
<p><img src="/cryptos_pci_devs.webp" alt="Placeholder image" title="Placeholder image"></p>
<p>Looking back at the QEMU terminal, we can see it has detected PCI configuration reads as we expected and it matches what our OS reports!
The string formatting is as follows <code>pci_cfg_read(const char *dev, unsigned devid, unsigned fnid, unsigned offs, unsigned val) &quot;%s %02u:%u @0x%x -&gt; 0x%x&quot;</code> <a href="https://lxr.missinglinkelectronics.com/qemu+v2.5.1/trace-events#L1615">(source)</a>.</p>
<pre tabindex="0"><code class="language-bash=" data-lang="bash=">pci_cfg_read i440FX 00:0 @0x0 -&gt; 0x12378086
pci_cfg_read i440FX 00:0 @0x0 -&gt; 0x12378086
pci_cfg_read i440FX 00:0 @0x8 -&gt; 0x6000002
pci_cfg_read i440FX 00:0 @0x3c -&gt; 0x0
pci_cfg_read PIIX3 01:0 @0x0 -&gt; 0x70008086
pci_cfg_read PIIX3 01:0 @0x0 -&gt; 0x70008086
pci_cfg_read PIIX3 01:0 @0x8 -&gt; 0x6010000
pci_cfg_read PIIX3 01:0 @0x3c -&gt; 0x0
pci_cfg_read piix3-ide 01:1 @0x0 -&gt; 0x70108086
pci_cfg_read piix3-ide 01:1 @0x0 -&gt; 0x70108086
pci_cfg_read piix3-ide 01:1 @0x8 -&gt; 0x1018000
pci_cfg_read piix3-ide 01:1 @0x3c -&gt; 0x0
pci_cfg_read PIIX4_PM 01:3 @0x0 -&gt; 0x71138086
pci_cfg_read PIIX4_PM 01:3 @0x0 -&gt; 0x71138086
pci_cfg_read PIIX4_PM 01:3 @0x8 -&gt; 0x6800003
pci_cfg_read PIIX4_PM 01:3 @0x3c -&gt; 0x109
pci_cfg_read VGA 02:0 @0x0 -&gt; 0x11111234
pci_cfg_read VGA 02:0 @0x0 -&gt; 0x11111234
pci_cfg_read VGA 02:0 @0x8 -&gt; 0x3000002
pci_cfg_read VGA 02:0 @0x3c -&gt; 0x0
pci_cfg_read e1000 03:0 @0x0 -&gt; 0x100e8086
pci_cfg_read e1000 03:0 @0x0 -&gt; 0x100e8086
pci_cfg_read e1000 03:0 @0x8 -&gt; 0x2000003
pci_cfg_read e1000 03:0 @0x3c -&gt; 0x10b
</code></pre><p>You can also test this using the <code>lspci</code> utility from a guest Linux VM running under QEMU.</p>
<h2 id="dma-block-io">DMA Block I/O</h2>
<p>Finally, you can debug some DMA operations with the <code>dma_blk_io</code> trace flag. To see this in action, we can perform a disk read
which uses DMA.</p>
<p>The formatting is as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">dma_blk_io</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>dbs, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>bs, <span style="color:#66d9ef">int64_t</span> sector_num, <span style="color:#66d9ef">bool</span> to_dev) <span style="color:#e6db74">&#34;dbs=%p bs=%p sector_num=%&#34;</span> PRId64 <span style="color:#e6db74">&#34; to_dev=%d&#34;</span>
</span></span></code></pre></div><p>To trigger something predictable, we will run a <code>dd</code> of a 128 byte block (<code>dd if=/dev/sdb of=out bs=128 count=1</code>) at offset 0 and 16384.
When the first <code>dd</code> is run, you can see the result on line 3 (offset is 0). The second <code>dd</code> run corresponds to line 4.</p>
<pre tabindex="0"><code class="language-bash=" data-lang="bash=">dma_blk_io dbs=0x7f2364044cb0 bs=0x558d815ec630 offset=1364811776 to_dev=0
dma_blk_io dbs=0x7f2364048730 bs=0x558d815ec630 offset=1364844544 to_dev=0
dma_blk_io dbs=0x7f2364048730 bs=0x558d815bce00 offset=0 to_dev=0
dma_blk_io dbs=0x7f236c218600 bs=0x558d815bce00 offset=16384 to_dev=0
dma_blk_io dbs=0x7f2370663940 bs=0x558d815ec630 offset=1517211648 to_dev=0
dma_blk_io dbs=0x7f2370663940 bs=0x558d815ec630 offset=1517215744 to_dev=0
...
</code></pre><p>There&rsquo;s obviously a lot of other DMA operations going on and this is likely due to background I/O operations by Ubuntu which is the guest OS in this experiment.</p>

    </article>

    
    
    <div class="pagination" style="margin-top:3rem;">
      <a href="http://localhost:51372/post/hp-z620-uefi-backdoor/">← HP z620 UEFI Backdoor</a>
      <a href="http://localhost:51372/post/linux-kernel-rootkit/">Linux Kernel Rootkit Basics →</a>
    </div>
    
  </div>

</div>

  </main><footer class="site-footer">
  <div class="container">
    <div class="footer-left">
      <strong>x86sec</strong> — a cybersecurity blog<br>
      &copy; 2026 Grant Foudree
    </div>
    <div class="footer-links">
      <a href="https://github.com/gfoudree" rel="noopener">github</a>
    </div>
  </div>
</footer>
<script src="/js/main.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>
