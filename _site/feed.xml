<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-02-12T12:01:24-06:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">x86Sec</title><subtitle>Personal Blog</subtitle><author><name>Grant Foudree</name><email>gfoudree@protonmail.com</email></author><entry><title type="html">Anti Reverse Engineering Tricks</title><link href="http://localhost:4000/2018-03-05/anti-reverse-engineering" rel="alternate" type="text/html" title="Anti Reverse Engineering Tricks" /><published>2018-03-05T00:00:00-06:00</published><updated>2018-03-05T00:00:00-06:00</updated><id>http://localhost:4000/2018-03-05/anti-reverse-engineering</id><content type="html" xml:base="http://localhost:4000/2018-03-05/anti-reverse-engineering">&lt;h2 id=&quot;jumping-over-opcodes&quot;&gt;Jumping Over Opcodes&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
It is not uncommon for malware to attempt to obfuscate its behavior in various ways to avoid analysis. In this post we will go over
some common tricks used to confuse static analysis tools from obtaining the correct disassembly of a program.&lt;/p&gt;

&lt;p&gt;A very simple trick is to jump over instructions that we don’t want to execute. Obviously this can get more complex, but the concept is simple.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-assembly&quot; data-lang=&quot;assembly&quot;&gt;//Compile with gcc trick1.S
.text
.global main
main:
	jmp L1 + 1
L1:
	.byte 0xc3               //Disassembler interprets this as a &quot;ret&quot; when we are really jumping over this (jmp L1 + 1)
	movq $1, %rax

exit:
	mov $60, %rax
	xor %rdi, %rdi
	syscall                  //Call exit(1)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The disassembly of the binary is shown below (objdump)&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-basy&quot; data-lang=&quot;basy&quot;&gt;0000000000400487 &amp;lt;main&amp;gt;:
  400487:	eb 01                	jmp    40048a &amp;lt;L1+0x1&amp;gt;

0000000000400489 &amp;lt;L1&amp;gt;:
  400489:	c3                   	ret                 //It appears as if we are returning here, but we never execute this opcode
  40048a:	48 c7 c0 01 00 00 00 	mov    rax,0x1      //We jump here

0000000000400491 &amp;lt;exit&amp;gt;:
  400491:	48 c7 c0 3c 00 00 00 	mov    rax,0x3c
  400498:	48 31 ff             	xor    rdi,rdi
  40049b:	0f 05                	syscall
  40049d:	0f 1f 00             	nop    DWORD PTR [rax]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Some disassemblers can be easily tricked by making the program appear as if it jumps into the middle of an opcode. This has a cascading effect
  of causing the disassembler to misinterpret most of the surrounding code, effectively obfuscating it.&lt;/p&gt;

&lt;h2 id=&quot;invalid-opcodes&quot;&gt;Invalid Opcodes&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
We will use a technique that combines the trick above with an alternative way to jump to code in order to confuse the disassembler.
  Recall that the “call” instruction pushes the address of the next instruction to the stack then jumps to the location.
  We can have fun with this by using it to get the current value of RIP, adding some value to it, pushing it to the stack and calling “ret”
  effectively making a dynamic “jmp” instruction. The disassembler, however, does not really know we are jumping somewhere as it never
  sees a “jmp” instruction.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-assembly&quot; data-lang=&quot;assembly&quot;&gt;call L1+1		//0xe8, 0x01, 0x00, 0x00	[Push RIP of return addr to stack and jump to 'pop rax']
L1: .byte 0xe9          //0xe9 				[Dummy val to confuse disasm]
pop rax 		//0x58 				[RIP = addr of this instruction, rax = RIP]
add rax, 9		//0x48, 0x83, 0xc0, 0x09	[+9 to our jump addr, 9 since prev ins = RIP and target (nop) is +9 ops away]
push rax		//0x50				[Push our modified ret addr to stack]
ret			//0xc3				[Pop return addr into RIP (effectively a jmp))]
.byte 0xe9 		//0xe9				[Trick the disasm again...]
nop			//0x90				[This is our target, can be anything]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The disassembly is shown below (objdump)&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-basy&quot; data-lang=&quot;basy&quot;&gt;0000000000400487 &amp;lt;main&amp;gt;:
  400487:	55                   	push   rbp
  400488:	48 89 e5             	mov    rbp,rsp
  40048b:	e8 01 00 00 00       	call   400491 &amp;lt;L1+0x1&amp;gt;&amp;gt;

0000000000400490 &amp;lt;L1&amp;gt;:
  400490:	e9 58 48 83 c0       	jmp    ffffffffc0c34ced &amp;lt;__TMC_END__+0xffffffffc0633ccd&amp;gt;
  400495:	09 50 c3             	or     DWORD PTR [rax-0x3d],edx
  400498:	e9 90 b8 00 00       	jmp    40bd2d &amp;lt;__FRAME_END__+0xb6f9&amp;gt;
  40049d:	00 00                	add    BYTE PTR [rax],al
  40049f:	5d                   	pop    rbp
  4004a0:	c3                   	ret
  4004a1:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  4004a8:	00 00 00
  4004ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;And in Radare2…&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;0x004003b0]&amp;gt; pdf @ main
            &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; main:
/ &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;fcn&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; main 14
|   main &lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
|              &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; UNKNOWN XREF from 0x0040048b &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;main&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
|              &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; DATA XREF from 0x004003cd &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;entry0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
|           0x00400487      55             push rbp
|           0x00400488      4889e5         mov rbp, rsp
|           0x0040048b      e801000000     call 0x400491
|           &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; L1:
&lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt;      ,&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;lt; 0x00400490      e9584883c0     jmp 0xffffffffc0c34ced
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;0x004003b0]&amp;gt; pd 5 @ 0xffffffffc0c34ced
            0xffffffffc0c34ced      ff             invalid
            0xffffffffc0c34cee      ff             invalid
            0xffffffffc0c34cef      ff             invalid
            0xffffffffc0c34cf0      ff             invalid
            0xffffffffc0c34cf1      ff             invalid
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;0x004003b0]&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;As you can see, the disassembly is quite different from the actual assembly above. Both disassemblers have been confused and our code, obfuscated.&lt;/p&gt;</content><author><name>Grant</name></author><summary type="html">Jumping Over Opcodes It is not uncommon for malware to attempt to obfuscate its behavior in various ways to avoid analysis. In this post we will go over some common tricks used to confuse static analysis tools from obtaining the correct disassembly of a program.</summary></entry><entry><title type="html">TEG-S18TXE Switch Reverse Engineering</title><link href="http://localhost:4000/2017-11-11/switch-reverse-engineering" rel="alternate" type="text/html" title="TEG-S18TXE Switch Reverse Engineering" /><published>2017-11-11T00:00:00-06:00</published><updated>2017-11-11T00:00:00-06:00</updated><id>http://localhost:4000/2017-11-11/switch-reverse-engineering</id><content type="html" xml:base="http://localhost:4000/2017-11-11/switch-reverse-engineering">&lt;p&gt;I happened to have an old &lt;a href=&quot;https://www.trendnet.com/products/proddetail?prod=185_TEG-S18TXE&quot;&gt;Trendnet TEG-S18TXE switch&lt;/a&gt;
  laying around the lab at work, so I decided to open it up and see if there was
  anything interesting inside. Usually, “dumb” switches do not contain many interesting hackable components
  as they are rather simplistic devices, however I got lucky and spotted an EEPROM chip on the board. If you look closely,
  you might notice that it is an Atmel AT93C46, 1K serial EEPROM.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/board1.png&quot; alt=&quot;Placeholder image&quot; title=&quot;Placeholder image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Interestingly, there appear to be unpopulated headers right below the chip that are connected to some of the pins on the EEPROM.
  Instead of soldering on some pins to the headers, I decided to use a SOP16 Clip which allowed me to access the pins on the DIP chip quite nicely.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/board2.png&quot; alt=&quot;Placeholder image&quot; title=&quot;Placeholder image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Following the datasheet &lt;a href=&quot;http://www.atmel.com/Images/doc5140.pdf&quot;&gt;here&lt;/a&gt;, I grabbed a spare Arduino Pro Micro and hooked up the wires as such:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/chip1.png&quot; alt=&quot;Placeholder image&quot; title=&quot;Placeholder image&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;EEPROM&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Arduino&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;VCC&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;VCC&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GND&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GND&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;SK&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;SCLK (Pin 15)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;CS&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Pin 9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;DI&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;MOSI (Pin 16)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;DO&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;MISO (Pin 14)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;With everything connected, the only thing left to do was write some code to dump the EEPROM.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;SPI.h&amp;gt;
#define SS_PIN 9
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pinMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SS_PIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OUTPUT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;digitalWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SS_PIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LOW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;Serial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9600&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;SPI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;SPI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setClockDivider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SPI_CLOCK_DIV128&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;SPI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setDataMode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SPI_MODE0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;SPI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setBitOrder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MSBFIRST&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;128&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;digitalWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SS_PIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HIGH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SPI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transfer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SPI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transfer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Address to read&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;b1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SPI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transfer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SPI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transfer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;digitalWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SS_PIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LOW&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;b1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Serial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DEC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Serial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; = &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Serial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HEX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Success! Monitoring the serial console gives a dump of the entire chip, but it looks like only the first 0x23 bytes contain data - the rest are zeros.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;xxd eeprom_dump.bin
00000000: 8daa 01ff 1a00 0112 0002 01ff 0000 0128  ...............&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
00000010: ffff 01ff 0000 02fa 7800 68ea 01ff 3300  ........x.h...3.
00000020: 012a 0018   &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;At this point it is pretty difficult to discern what each byte/bit corresponds to. I tried hooking up the switch to a couple computers and doing a large
  file transfer, as well as power-cycling the device several times in an attempt to expose some hints. However when I dumped the EEPROM after, nothing had changed.
  My best guess is that the unpopulated header on the board is used to program some simple configuration settings to the device during production and that is the extent
  to which the chip is written to. Since EEPROM has limited write cycles, combined with the fact that unmanaged switches don’t really need to store persistant data, it
  is unlikely this EEPROM gets modified.&lt;/p&gt;</content><author><name>Grant</name></author><summary type="html">I happened to have an old Trendnet TEG-S18TXE switch laying around the lab at work, so I decided to open it up and see if there was anything interesting inside. Usually, “dumb” switches do not contain many interesting hackable components as they are rather simplistic devices, however I got lucky and spotted an EEPROM chip on the board. If you look closely, you might notice that it is an Atmel AT93C46, 1K serial EEPROM.</summary></entry></feed>