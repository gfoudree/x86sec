I"a.<p>Picking apart firmware is quite interesting to me and so I thought it would be fun to reverse engineer my desktop’s BIOS and see what I could find.</p>

<h1 id="extracting-uefi-modules">Extracting UEFI Modules</h1>

<hr />

<p><br /></p>

<p>My desktop is an HP z620 and the latest BIOS version is <a href="/assets/J61_0396.bin">J61_0396.bin</a>. Most UEFI BIOS images are a collection of modules (drivers, microcode, applications, etc…) that can be extracted and examined. The drivers and applications are PE32+ executables which is convenient as many reverse engineering tools support this executable format. We can examine/modify the BIOS image with <a href="https://github.com/LongSoft/UEFITool">UEFITool</a> and pick apart the sections of interest.</p>

<p>An easy section to look at is where the POST logo is stored. Here it’s conveniently called “Logo” and we can extract it as a <code class="highlighter-rouge">.bmp</code> file and see it is the same logo shown during POST.</p>

<p><img src="/assets/bios_logo.png" alt="Placeholder image" title="UEFITool bios logo section" /> <img src="/assets/hp_bios_logo.png" alt="Placeholder image" title="HP BIOS logo" />
<br /></p>

<p>Sifting through the remaining sections, <code class="highlighter-rouge">BiosDiags</code> and <code class="highlighter-rouge">AbsoluteDriver</code> stood out as interesting as they are both applications.
<br />
<br /></p>

<p><img src="/assets/uefi_biosdiags_efi.png" alt="Placeholder image" title="UEFITool BiosDiags.efi" />
<br /></p>

<h1 id="reverse-engineering-biosdiagsefi">Reverse Engineering BiosDiags.efi</h1>

<hr />

<p><br /></p>

<p>After extracting the <code class="highlighter-rouge">BiosDiags</code> section (Right-click “PE32 Image Section” -&gt; “Extract Body”), let’s open it up in Ghidra to have a look…</p>

<p><strong>Note:</strong> to help with analyzing BIOS images, the plugins <a href="https://github.com/al3xtjames/ghidra-firmware-utils">ghidra-firmware-utils</a> and <a href="https://github.com/DSecurity/efiSeek">efiSeek</a> are helpful.</p>

<p>Looking for strings, <code class="highlighter-rouge">rpcnetp.exe</code> shows up inside shortly followed by the familiar <code class="highlighter-rouge">MZ</code> header which indicates a PE executable file. Interesting… The suspected PE executable is in the <code class="highlighter-rouge">.data</code> section of <code class="highlighter-rouge">BiosDiags.efi</code> which further raises suspicion that this is an embedded program to be dumped somewhere and not executed as part of <code class="highlighter-rouge">BiosDiags.efi</code>.</p>

<p><img src="/assets/embedded_pe_header.png" alt="Placeholder image" title="embedded PE header" /></p>

<h1 id="running-biosdiagsefi">Running BiosDiags.efi</h1>

<hr />

<p><br /></p>

<p>Let’s confirm our suspicions and run <code class="highlighter-rouge">BiosDiags.efi</code> in QEMU with an attached disk with Windows XP installed to see what happens.</p>

<p>An easy way to run EFI programs is launch QEMU with a UEFI BIOS, get a UEFI shell and invoke the program from there. Download a UEFI shell (or use <a href="/assets/Shell.efi">this one</a>) and build an EFI-bootable FAT32 disk.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">dd </span><span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>disk.img <span class="nv">bs</span><span class="o">=</span>1M <span class="nv">count</span><span class="o">=</span>64
mkfs.msdos disk.img
mmd <span class="nt">-i</span> disk.img ::/EFI
mmd <span class="nt">-i</span> disk.img ::/EFI/BOOT

<span class="c"># Copy in shell &amp; BiosDiags.efi</span>
mcopy <span class="nt">-i</span> disk.img Shell.efi ::/EFI/BOOT/Bootx64.efi
mcopy <span class="nt">-i</span> disk.img BiosDiags.efi ::/</code></pre></figure>

<p>Invoke QEMU and attach a disk image with Windows XP installed (you can install the OVMF UEFI firmware on Ubuntu with <code class="highlighter-rouge">apt install ovmf</code>)</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">qemu-system-x86_64 <span class="nt">-drive</span> <span class="nv">format</span><span class="o">=</span>raw,file<span class="o">=</span>disk.img <span class="se">\</span>
    <span class="nt">-smp</span> 2 <span class="nt">-m</span> 4096 <span class="nt">-bios</span> /usr/share/qemu/OVMF.fd <span class="se">\</span>
    <span class="nt">-drive</span> <span class="nv">media</span><span class="o">=</span>disk,file<span class="o">=</span>WindowsXP_1.vmdk </code></pre></figure>

<p>Once QEMU starts up, you can drop into a shell and invoke <code class="highlighter-rouge">BiosDiags.efi</code></p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">FS0:
BiosDiags.efi</code></pre></figure>

<p><img src="/assets/qemu_biosdiags_efi.png" alt="qemubiosdiags" title="running BiosDiags.efi in QEMU" /></p>

<p>Booting up XP we can see that two new files are implanted in <code class="highlighter-rouge">C:\Windows\System32\</code> as suspected (<code class="highlighter-rouge">rpcnetp.exe</code> and <code class="highlighter-rouge">rpcnetp.dll</code>) and <code class="highlighter-rouge">rpcnetp.exe</code> is running as <code class="highlighter-rouge">SYSTEM</code> on the machine. Nice!</p>

<p><img src="/assets/backdoor_running.png" alt="xpbackdoor" title="backdoor running" /></p>

<p>It is worth noting that trying this again on a Windows 7 machine does not produce the same results, and no <code class="highlighter-rouge">rpcnet.exe</code> is dropped.
<br />
<br /></p>

<h1 id="wpbt-windows-platform-binary-table">WPBT (Windows Platform Binary Table)</h1>
<hr />

<p><br /></p>

<p>This sort of behavior looks a lot like a bootkit but, to my surprise, Windows provides an official way to do this via the <a href="https://download.microsoft.com/download/8/A/2/8A2FB72D-9B96-4E2D-A559-4A27CF905A80/windows-platform-binary-table.docx">Windows Platform Binary Table</a> (WPBT). In essence, the WPBT allows UEFI firmware to register a PE file to be run during system initialization by inserting it into an ACPI table. The ACPI table format looks like this (see above link for full details):</p>

<p><img src="/assets/wpbt_layout.png" alt="wpbtlayout" title="wpbt layout" /></p>

<p>It appears as if this is exactly what is going on here. Let’s have a look.</p>

<p><img src="/assets/acpi_table_manipulation.png" alt="acpitable" title="acpi table manipulation" />
<br />
In this function, <code class="highlighter-rouge">0x80005de0</code>, we can see it accessing some ACPI tables in the beginning.</p>

<p>In Microsoft’s documentation for WPBT, UEFI firmware is supposed to allocate memory for the WPBT ACPI table via the <code class="highlighter-rouge">AllocatePages()</code> service with an allocation type of <code class="highlighter-rouge">AllocateAnyPages</code> and the <code class="highlighter-rouge">EfiACPIReclaimMemory</code> flag set. This is <strong>exactly</strong> what we see later on inside <code class="highlighter-rouge">0x80005de0</code> :).</p>

<p><br />
<img src="/assets/acpi_alloc_pages.png" alt="allocpages" title="alloc pages" />
<br /></p>

<p>Lines 64 &amp; 65 perform this allocation, with line 68 invoking a function that takes in the PE code for the dropped <code class="highlighter-rouge">rpcnetp.exe</code> file. Finally, line 69 stores the result in <code class="highlighter-rouge">Table</code> which is our ACPI table that will be used to implement WPBT.</p>

<p><br />
<img src="/assets/wpbt_table.png" alt="wpbttable" title="wpbt table" />
<br /></p>

<p>Continuing on, we can see the WPBT fields being filled out per the specification. Line 111 sets the mandatory <code class="highlighter-rouge">WPBT</code> signature (<code class="highlighter-rouge">0x54425057</code> translates to “WPBT”). On line 119 we can see the <code class="highlighter-rouge">DAT_800010a8</code> value referenced again and set as the length of the PE data (<code class="highlighter-rouge">puVar14</code> is a 32-bit variable so <code class="highlighter-rouge">puVar14[9]</code> = 4*9 -&gt; 36). The content flag is set to 1 (indicating a PE file) and finally the memory location is set to that allocated buffer the PE data was copied into above.</p>

<p>Skipping over some lines, we eventually come to the end of the function where we can see the new ACPI table being installed with <code class="highlighter-rouge">InstallConfigurationTable()</code> and it’s GUID, exactly as outlined in Microsoft’s documentation.
<br /></p>

<p><img src="/assets/install_wpbt.png" alt="installwpbt" title="wpbt install" /></p>

<h1 id="dropped-file-analysis">Dropped file analysis</h1>
<hr />

<p><br /></p>

<p>Running both the files through Virustotal shows both files flagging 1 AV out of 67 (<a href="https://www.virustotal.com/gui/file/1c6a20980a186225979f5e91bc48eaf77c67f50eea85eba9db4c3ec55c61d55f/detection">rpcnetp.exe</a> <a href="https://www.virustotal.com/gui/file/56c9ab9a663af6af931b3c76f32ed0f7402d6ed39f3538f72cb2757886ef7c40/detection">rpcnetp.dll</a>)</p>

<p>Digging further, it appears this program is called “Computrace” and has been around for a while. I suppose the string at the beginning of the EFI file should have alerted me to this as well…</p>

<p><img src="/assets/computrace.png" alt="computrace" title="computrace" /></p>

<p>If you’re interested, you can read more about it here from this <a href="http://blackhat.com/docs/us-14/materials/us-14-Kamlyuk-Kamluk-Computrace-Backdoor-Revisited.pdf">Blackhat 14 Presentation</a> which goes over what it does.</p>

<h1 id="closing-thoughts">Closing thoughts</h1>
<hr />

<p><br /></p>

<p>While it appears as if Computrace does not deploy on newer Windows installations, it is important to realize this method of stealthily dropping executables into a OS install is a very real concept and is being used. Microsoft provides a way for vendors to do this so it is highly likely other software is being installed this way as well. Although other operating systems, like Linux, don’t provide a built-in way to do this, accessing the disk in a pre-boot environment and dropping executables or modifying the guest OS is quite realistic. Since BIOS code is mostly black-box software that runs with high privilege before the OS boots, one should realize the trust we place in this firmware that we cannot control nor do we understand everything it does.</p>

<h1 id="files">Files</h1>
<hr />

<p><br /></p>

<h4 id="hp-bios--efi-modules">HP BIOS &amp; EFI Modules</h4>
<p><a href="/assets/BiosDiags.efi"><code class="highlighter-rouge">BiosDiags.efi</code></a>:<code class="highlighter-rouge">71b01f0ad7c1d990771aa675bc814d5f9b50a7958c005173cda0165139235666</code>
<a href="/assets/J61_0396.bin"><code class="highlighter-rouge">J61_0396.bin</code></a>:<code class="highlighter-rouge">05e89382e73afb280f637acbfa1029e9107dd30c78df37b6a00f184657f5f2c3</code></p>

<h4 id="uefi-bios-for-qemu">UEFI BIOS for QEMU</h4>
<p><a href="/assets/OVMF.fd"><code class="highlighter-rouge">OVMF.fd</code></a>:<code class="highlighter-rouge">96a9aad279ac9fdb7d452b70cee71587a917aaa428e4c40e9a9cb35f5d718259</code>
<a href="/assets/Shell.efi"><code class="highlighter-rouge">Shell.efi</code></a>:<code class="highlighter-rouge">04c89f19efee2a22660fd4650ff9add88e962d102b1b713e535f4e32a07c5185</code></p>

<h4 id="computrace">Computrace</h4>
<p><a href="/assets/rpcnetp.dll"><code class="highlighter-rouge">rpcnetp.dll</code></a>:<code class="highlighter-rouge">56c9ab9a663af6af931b3c76f32ed0f7402d6ed39f3538f72cb2757886ef7c40</code>
<a href="/assets/rpcnetp.exe"><code class="highlighter-rouge">rpcnetp.exe</code></a>:<code class="highlighter-rouge">1c6a20980a186225979f5e91bc48eaf77c67f50eea85eba9db4c3ec55c61d55f</code></p>
:ET