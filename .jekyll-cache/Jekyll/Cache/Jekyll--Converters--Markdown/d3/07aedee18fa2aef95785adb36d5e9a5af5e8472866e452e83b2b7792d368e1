I"V<p>I happened to have an old <a href="https://www.trendnet.com/products/proddetail?prod=185_TEG-S18TXE">Trendnet TEG-S18TXE switch</a>
  laying around the lab at work, so I decided to open it up and see if there was
  anything interesting inside. Usually, “dumb” switches do not contain many interesting hackable components
  as they are rather simplistic devices, however I got lucky and spotted an EEPROM chip on the board. If you look closely,
  you might notice that it is an Atmel AT93C46, 1K serial EEPROM.</p>

<p><img src="/assets/board1.png" alt="Placeholder image" title="Placeholder image" /></p>

<p>Interestingly, there appear to be unpopulated headers right below the chip that are connected to some of the pins on the EEPROM.
  Instead of soldering on some pins to the headers, I decided to use a SOP16 Clip which allowed me to access the pins on the DIP chip quite nicely.</p>

<p><img src="/assets/board2.png" alt="Placeholder image" title="Placeholder image" /></p>

<p>Following the datasheet <a href="http://www.atmel.com/Images/doc5140.pdf">here</a>, I grabbed a spare Arduino Pro Micro and hooked up the wires as such:</p>

<p><img src="/assets/chip1.png" alt="Placeholder image" title="Placeholder image" /></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">EEPROM</th>
      <th style="text-align: center">Arduino</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">VCC</td>
      <td style="text-align: center">VCC</td>
    </tr>
    <tr>
      <td style="text-align: center">GND</td>
      <td style="text-align: center">GND</td>
    </tr>
    <tr>
      <td style="text-align: center">SK</td>
      <td style="text-align: center">SCLK (Pin 15)</td>
    </tr>
    <tr>
      <td style="text-align: center">CS</td>
      <td style="text-align: center">Pin 9</td>
    </tr>
    <tr>
      <td style="text-align: center">DI</td>
      <td style="text-align: center">MOSI (Pin 16)</td>
    </tr>
    <tr>
      <td style="text-align: center">DO</td>
      <td style="text-align: center">MISO (Pin 14)</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>With everything connected, the only thing left to do was write some code to dump the EEPROM.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;SPI.h&gt;
#define SS_PIN 9
</span>
<span class="kt">void</span> <span class="nf">setup</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pinMode</span><span class="p">(</span><span class="n">SS_PIN</span><span class="p">,</span> <span class="n">OUTPUT</span><span class="p">);</span>
  <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SS_PIN</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>

  <span class="n">Serial</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="mi">9600</span><span class="p">);</span>

  <span class="n">SPI</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
  <span class="n">SPI</span><span class="p">.</span><span class="n">setClockDivider</span><span class="p">(</span><span class="n">SPI_CLOCK_DIV128</span><span class="p">);</span>
  <span class="n">SPI</span><span class="p">.</span><span class="n">setDataMode</span><span class="p">(</span><span class="n">SPI_MODE0</span><span class="p">);</span>
  <span class="n">SPI</span><span class="p">.</span><span class="n">setBitOrder</span><span class="p">(</span><span class="n">MSBFIRST</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">byte</span> <span class="n">data</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SS_PIN</span><span class="p">,</span> <span class="n">HIGH</span><span class="p">);</span>
    <span class="n">SPI</span><span class="p">.</span><span class="n">transfer</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">SPI</span><span class="p">.</span><span class="n">transfer</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">//Address to read</span>
    <span class="n">delay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="n">b1</span> <span class="o">=</span> <span class="n">SPI</span><span class="p">.</span><span class="n">transfer</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="n">SPI</span><span class="p">.</span><span class="n">transfer</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="n">digitalWrite</span><span class="p">(</span><span class="n">SS_PIN</span><span class="p">,</span> <span class="n">LOW</span><span class="p">);</span>

    <span class="n">b1</span> <span class="o">=</span> <span class="n">b1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="n">b2</span> <span class="o">&gt;&gt;</span> <span class="mi">7</span><span class="p">;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">b1</span> <span class="o">|</span> <span class="n">b2</span><span class="p">;</span>

    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">DEC</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="s">" = "</span><span class="p">);</span>
    <span class="n">Serial</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">HEX</span><span class="p">);</span>
    <span class="n">delay</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Success! Monitoring the serial console gives a dump of the entire chip, but it looks like only the first 0x23 bytes contain data - the rest are zeros.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>xxd eeprom_dump.bin
00000000: 8daa 01ff 1a00 0112 0002 01ff 0000 0128  ...............<span class="o">(</span>
00000010: ffff 01ff 0000 02fa 7800 68ea 01ff 3300  ........x.h...3.
00000020: 012a 0018   
</code></pre></div></div>

<p>At this point it is pretty difficult to discern what each byte/bit corresponds to. I tried hooking up the switch to a couple computers and doing a large
  file transfer, as well as power-cycling the device several times in an attempt to expose some hints. However when I dumped the EEPROM after, nothing had changed.
  My best guess is that the unpopulated header on the board is used to program some simple configuration settings to the device during production and that is the extent
  to which the chip is written to. Since EEPROM has limited write cycles, combined with the fact that unmanaged switches don’t really need to store persistant data, it
  is unlikely this EEPROM gets modified.</p>
:ET